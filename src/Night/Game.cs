// <copyright file="Game.cs" company="Night Circle">
// zlib license
//
// Copyright (c) 2025 Danny Solivan, Night Circle
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// </copyright>

using System;

using SDL3;

namespace Night
{
  /// <summary>
  /// Base class for a game that can be run by the Night Engine.
  /// Game developers can inherit from this class and override specific methods
  /// to implement their game logic, rather than implementing all methods from <see cref="IGame"/>.
  /// </summary>
  public abstract class Game : IGame
  {
    /// <summary>
    /// Called exactly once when the game starts for loading resources.
    /// Override this method to load game-specific assets.
    /// </summary>
    public virtual void Load()
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function used to update the state of the game every frame.
    /// Override this method to implement game logic.
    /// </summary>
    /// <param name="deltaTime">The time elapsed since the last frame, in seconds.</param>
    public virtual void Update(double deltaTime)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function used to draw on the screen every frame.
    /// Override this method to render game visuals.
    /// </summary>
    public virtual void Draw()
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a key is pressed.
    /// Override this method to handle key press events.
    /// </summary>
    /// <param name="key">The logical key symbol that was pressed.</param>
    /// <param name="scancode">The physical key (scancode) that was pressed.</param>
    /// <param name="isRepeat">True if this is a key repeat event, false otherwise.</param>
    public virtual void KeyPressed(KeySymbol key, KeyCode scancode, bool isRepeat)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a key is released.
    /// Override this method to handle key release events.
    /// </summary>
    /// <param name="key">The logical key symbol that was released.</param>
    /// <param name="scancode">The physical key (scancode) that was released.</param>
    public virtual void KeyReleased(KeySymbol key, KeyCode scancode)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a mouse button is pressed.
    /// Override this method to handle mouse button press events.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="y">The y-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="button">The mouse button that was pressed.</param>
    /// <param name="istouch">True if the event was generated by a touch input device, false otherwise.</param>
    /// <param name="presses">The number of clicks (1 for single-click, 2 for double-click, etc.).</param>
    public virtual void MousePressed(int x, int y, MouseButton button, bool istouch, int presses)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a mouse button is released.
    /// Override this method to handle mouse button release events.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="y">The y-coordinate of the mouse cursor relative to the window.</param>
    /// <param name="button">The mouse button that was released.</param>
    /// <param name="istouch">True if the event was generated by a touch input device, false otherwise.</param>
    /// <param name="presses">The number of clicks (typically 1 for release, but may vary).</param>
    public virtual void MouseReleased(int x, int y, MouseButton button, bool istouch, int presses)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick is connected.
    /// Override this method to handle joystick connection events.
    /// </summary>
    /// <param name="joystick">The Joystick object representing the connected device.</param>
    public virtual void JoystickAdded(Joystick joystick)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick is disconnected.
    /// Override this method to handle joystick disconnection events.
    /// </summary>
    /// <param name="joystick">The Joystick object representing the disconnected device.</param>
    public virtual void JoystickRemoved(Joystick joystick)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick axis moves.
    /// Override this method to handle joystick axis motion events.
    /// </summary>
    /// <param name="joystick">The Joystick object.</param>
    /// <param name="axis">The index of the axis that moved.</param>
    /// <param name="value">The new value of the axis, typically in the range -1.0 to 1.0.</param>
    public virtual void JoystickAxis(Joystick joystick, int axis, float value)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick button is pressed.
    /// Override this method to handle joystick button press events.
    /// </summary>
    /// <param name="joystick">The Joystick object.</param>
    /// <param name="button">The index of the button that was pressed.</param>
    public virtual void JoystickPressed(Joystick joystick, int button)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick button is released.
    /// Override this method to handle joystick button release events.
    /// </summary>
    /// <param name="joystick">The Joystick object.</param>
    /// <param name="button">The index of the button that was released.</param>
    public virtual void JoystickReleased(Joystick joystick, int button)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a joystick hat direction changes.
    /// Override this method to handle joystick hat motion events.
    /// </summary>
    /// <param name="joystick">The Joystick object.</param>
    /// <param name="hat">The index of the hat that changed.</param>
    /// <param name="direction">The new direction of the hat.</param>
    public virtual void JoystickHat(Joystick joystick, int hat, JoystickHat direction)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a virtual gamepad axis is moved.
    /// Override this method to handle gamepad axis motion events.
    /// </summary>
    /// <param name="joystick">The Joystick object (which is also a gamepad).</param>
    /// <param name="axis">The virtual gamepad axis that moved.</param>
    /// <param name="value">The new value of the axis, typically in the range -1.0 to 1.0.</param>
    public virtual void GamepadAxis(Joystick joystick, GamepadAxis axis, float value)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a virtual gamepad button is pressed.
    /// Override this method to handle gamepad button press events.
    /// </summary>
    /// <param name="joystick">The Joystick object (which is also a gamepad).</param>
    /// <param name="button">The virtual gamepad button that was pressed.</param>
    public virtual void GamepadPressed(Joystick joystick, GamepadButton button)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Callback function triggered when a virtual gamepad button is released.
    /// Override this method to handle gamepad button release events.
    /// </summary>
    /// <param name="joystick">The Joystick object (which is also a gamepad).</param>
    /// <param name="button">The virtual gamepad button that was released.</param>
    public virtual void GamepadReleased(Joystick joystick, GamepadButton button)
    {
      // Default implementation is empty.
    }

    /// <summary>
    /// Provides the main game loop iteration logic as a callable function.
    /// This default implementation mirrors LÃ–VE's `love.run()` behavior for a single frame,
    /// returning a function that, when called, executes one iteration of the game loop.
    /// </summary>
    /// <returns>
    /// A function (mainLoopIteration) which handles one frame, including event processing,
    /// updates, drawing, and timing. The returned function returns:
    /// - null: To indicate the game loop should continue.
    /// - int value (e.g., 0): To indicate the game should exit with the specified status code.
    /// </returns>
    public virtual Func<int?> Run()
    {
      // This lambda represents one iteration of the main game loop.
      return () =>
      {
        // Process SDL events
        SDL.Event sdlEvent;
        while (SDL.PollEvent(out sdlEvent))
        {
          var eventType = (SDL.EventType)sdlEvent.Type;
          switch (eventType)
          {
            case SDL.EventType.Quit:
              // If Quit() returns true, it means allow the game to close.
              if (this.Quit())
              {
                // Signal to exit the game loop with status 0.
                return 0;
              }

              // If Quit() returns false, the quit attempt is cancelled; continue processing.
              break;
            case SDL.EventType.KeyDown:
              this.KeyPressed((KeySymbol)sdlEvent.Key.Key, (KeyCode)sdlEvent.Key.Scancode, sdlEvent.Key.Repeat);
              break;
            case SDL.EventType.KeyUp:
              this.KeyReleased((KeySymbol)sdlEvent.Key.Key, (KeyCode)sdlEvent.Key.Scancode);
              break;
            case SDL.EventType.MouseButtonDown:
              this.MousePressed(
                  (int)sdlEvent.Button.X,
                  (int)sdlEvent.Button.Y,
                  (MouseButton)sdlEvent.Button.Button,
                  sdlEvent.Button.Which == SDL.TouchMouseID,
                  sdlEvent.Button.Clicks);
              break;
            case SDL.EventType.MouseButtonUp:
              this.MouseReleased(
                  (int)sdlEvent.Button.X,
                  (int)sdlEvent.Button.Y,
                  (MouseButton)sdlEvent.Button.Button,
                  sdlEvent.Button.Which == SDL.TouchMouseID,
                  sdlEvent.Button.Clicks);
              break;

              // TODO: Implement full joystick and gamepad event handling here
              // similar to Framework.Events.cs if this Run() model is adopted.
              // e.g., JoystickAdded, JoystickRemoved, JoystickAxis, JoystickButton, etc.
              // e.g., GamepadAxis, GamepadButton, etc.
          }
        }

        // Update delta time
        double dt = Night.Timer.Step();

        // Call user's update logic
        this.Update(dt);

        // Draw graphics
        // Only draw if the window is actually open
        if (Night.Window.IsOpen())
        {
          // Assuming Night.Graphics.GetBackgroundColor() and Night.Graphics.Clear(Color) exist
          // based on available test file names (GraphicsBackgroundColorTests, GraphicsClearTest).
          Night.Graphics.Clear(Night.Graphics.GetBackgroundColor());
          this.Draw();
          Night.Graphics.Present();
        }

        // Brief sleep, as in LÃ–VE's example
        Night.Timer.Sleep(0.001);

        // Signal to continue the game loop.
        return null;
      };
    }

    /// <summary>
    /// Callback function triggered when the game is about to close.
    /// The default implementation allows the game to quit.
    /// </summary>
    /// <returns>
    /// False to cancel the quit attempt (and continue running the game),
    /// true to allow the game to close.
    /// </returns>
    public virtual bool Quit()
    {
      // Default behavior: allow the game to quit.
      return true;
    }
  }
}
