// <copyright file="GameTestCase.cs" company="Night Circle">
// zlib license
//
// Copyright (c) 2025 Danny Solivan, Night Circle
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// </copyright>

using System;
using System.Diagnostics;

using Night;

namespace NightTest.Core
{
  /// <summary>
  /// Abstract base class for test cases to reduce boilerplate.
  /// Implements ITestCase and Night.IGame.
  /// </summary>
  public abstract class GameTestCase : BaseTestCase, IGame
  {
    // Protected Properties

    /// <summary>
    /// Gets or sets a value indicating whether the test case has finished its execution.
    /// </summary>
    protected bool IsDone { get; set; } = false;

    /// <summary>
    /// Gets the current frame count since the test started. Incremented in Update.
    /// </summary>
    protected int CurrentFrameCount { get; private set; } = 0;

    /// <summary>
    /// Loads and initializes the test case. This is the entry point called by the test runner
    /// or game loop, fulfilling the <see cref="IGame"/> interface.
    /// It performs common base setup and then calls <see cref="InternalLoad"/>.
    /// </summary>
    void IGame.Load()
    {
      this.IsDone = false;
      this.CurrentStatus = TestStatus.NotRun; // Reverted: Enum does not contain 'Running'
      this.Details = "Test is running...";
      this.CurrentFrameCount = 0;
      this.TestStopwatch.Reset();
      this.TestStopwatch.Start();

      // Call the virtual InternalLoad, allowing intermediate classes to intercept.
      this.InternalLoad();
    }

    /// <summary>
    /// Updates the test case logic. This is the entry point called by the test runner
    /// or game loop, fulfilling the <see cref="IGame"/> interface.
    /// </summary>
    /// <param name="deltaTime">Time elapsed since the last frame.</param>
    void IGame.Update(double deltaTime)
    {
      if (this.IsDone)
      {
        return;
      }

      this.CurrentFrameCount++;

      try
      {
        // Call the virtual InternalUpdate, allowing intermediate classes to intercept.
        this.InternalUpdate(deltaTime);
      }
      catch (System.Exception ex)
      {
        // Record failure if an unhandled exception occurs in the test's Update logic
        this.RecordFailure($"Unhandled exception in Update: {ex.GetType().Name} - {ex.Message}", ex);
      }
    }

    /// <summary>
    /// Draws the test case. This is the entry point called by the test runner
    /// or game loop, fulfilling the <see cref="IGame"/> interface.
    /// It calls <see cref="InternalDraw"/>.
    /// </summary>
    void IGame.Draw()
    {
      // Call the virtual InternalDraw, allowing intermediate classes to intercept.
      this.InternalDraw();
    }

    /// <summary>
    /// Called when a key is pressed. Default is empty.
    /// </summary>
    /// <param name="key">The key symbol that was pressed.</param>
    /// <param name="scancode">The physical key code.</param>
    /// <param name="isRepeat">True if this is a key repeat event, false otherwise.</param>
    public virtual void KeyPressed(KeySymbol key, KeyCode scancode, bool isRepeat)
    {
      if (this.IsDone || isRepeat)
      {
        return;
      }
    }

    /// <summary>
    /// Called when a key is released. Default is empty.
    /// </summary>
    /// <param name="key">The key symbol that was released.</param>
    /// <param name="scancode">The physical key code.</param>
    public virtual void KeyReleased(KeySymbol key, KeyCode scancode)
    {
    }

    /// <summary>
    /// Called when a mouse button is pressed.
    /// Base implementation handles clicks for manual confirmation UI.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse click.</param>
    /// <param name="y">The y-coordinate of the mouse click.</param>
    /// <param name="button">The mouse button that was pressed.</param>
    /// <param name="istouch">True if the event was generated by a touch input, false otherwise.</param>
    /// <param name="presses">The number of clicks, 1 for single-click, 2 for double-click, etc.</param>
    public virtual void MousePressed(int x, int y, MouseButton button, bool istouch, int presses)
    {
    }

    /// <summary>
    /// Called when a mouse button is released. Default is empty.
    /// </summary>
    /// <param name="x">The x-coordinate of the mouse release.</param>
    /// <param name="y">The y-coordinate of the mouse release.</param>
    /// <param name="button">The mouse button that was released.</param>
    /// <param name="istouch">True if the event was generated by a touch input, false otherwise.</param>
    /// <param name="presses">The number of clicks (usually 1 for release, but can be higher for some systems/drivers if tracking click counts on release).</param>
    public virtual void MouseReleased(int x, int y, MouseButton button, bool istouch, int presses)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickAdded(Joystick joystick)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickRemoved(Joystick joystick)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickAxis(Joystick joystick, int axis, float value)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickPressed(Joystick joystick, int button)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickReleased(Joystick joystick, int button)
    {
    }

    /// <inheritdoc/>
    public virtual void JoystickHat(Joystick joystick, int hat, JoystickHat direction)
    {
    }

    /// <inheritdoc/>
    public virtual void GamepadAxis(Joystick joystick, GamepadAxis axis, float value)
    {
    }

    /// <inheritdoc/>
    public virtual void GamepadPressed(Joystick joystick, GamepadButton button)
    {
    }

    /// <inheritdoc/>
    public virtual void GamepadReleased(Joystick joystick, GamepadButton button)
    {
    }

    /// <inheritdoc/>
    public Func<int?> Run()
    {
      throw new NotImplementedException();
    }

    /// <inheritdoc/>
    public bool Quit()
    {
      throw new NotImplementedException();
    }

    /// <summary>
    /// Performs the specific load logic for the test case.
    /// Derived classes can override this method to implement their core load behavior.
    /// This method is called by the <see cref="InternalLoad"/> method, which is ultimately
    /// invoked via the <see cref="IGame.Load"/> explicit interface implementation.
    /// Base implementation is empty.
    /// </summary>
    protected virtual void Load()
    {
    }

    /// <summary>
    /// Intermediate virtual method that can be overridden by specialized base classes
    /// (like <see cref="ManualTestCase"/>) to inject logic before or after
    /// the concrete test's <see cref="Load()"/> method is called.
    /// By default, it directly calls the concrete <see cref="Load()"/>.
    /// </summary>
    protected virtual void InternalLoad()
    {
      // Calls the abstract Load implemented by concrete test classes
      this.Load();
    }

    /// <summary>
    /// Performs the specific update logic for the test case.
    /// Derived classes must override this method to implement their core update behavior.
    /// This method is called by the <see cref="IGame.Update"/> explicit interface implementation.
    /// </summary>
    /// <param name="deltaTime">Time elapsed since the last frame.</param>
    protected abstract void Update(double deltaTime);

    /// <summary>
    /// Intermediate virtual method that can be overridden by specialized base classes
    /// (like <see cref="ManualTestCase"/>) to inject logic before or after
    /// the concrete test's <see cref="Update(double)"/> method is called.
    /// By default, it directly calls the concrete <see cref="Update(double)"/>.
    /// </summary>
    /// <param name="deltaTime">Time elapsed since the last frame.</param>
    protected virtual void InternalUpdate(double deltaTime)
    {
      // Calls the abstract Update implemented by concrete test classes (e.g., GraphicsClearColorTest or automated tests)
      this.Update(deltaTime);
    }

    /// <summary>
    /// Performs the specific draw logic for the test case.
    /// Derived classes can override this method to implement their core draw behavior.
    /// This method is called by the <see cref="InternalDraw"/> method, which is ultimately
    /// invoked via the <see cref="IGame.Draw"/> explicit interface implementation.
    /// Base implementation is empty.
    /// </summary>
    protected virtual void Draw()
    {
    }

    /// <summary>
    /// Intermediate virtual method that can be overridden by specialized base classes
    /// (like <see cref="ManualTestCase"/>) to inject logic before or after
    /// the concrete test's <see cref="Draw()"/> method is called.
    /// By default, it directly calls the concrete <see cref="Draw()"/>.
    /// </summary>
    protected virtual void InternalDraw()
    {
      // Calls the abstract Draw implemented by concrete test classes
      this.Draw();
    }

    /// <summary>
    /// Helper method to stop the stopwatch, record results, and close the window.
    /// Call this when your test logic determines completion (pass or fail).
    /// Ensure CurrentStatus and Details are set appropriately before calling.
    /// </summary>
    protected virtual void EndTest()
    {
      if (this.IsDone)
      {
        return;
      }

      this.TestStopwatch.Stop();

      if (Night.Window.IsOpen())
      {
        Night.Window.Close();
      }

      this.IsDone = true;
    }

    /// <summary>
    /// Checks if the test should complete based on a duration.
    /// Sets CurrentStatus, Details, and calls EndTest if completion occurs.
    /// </summary>
    /// <param name="milliseconds">The duration in milliseconds to wait.</param>
    /// <param name="successCondition">An optional function that must return true for the test to pass. If null, test passes on timeout.</param>
    /// <param name="passDetails">Details message if the test passes.</param>
    /// <param name="failDetailsTimeout">Details message if the test fails due to timeout (and no successCondition or it was false).</param>
    /// <param name="failDetailsCondition">Details message if the test fails because successCondition was false at timeout.</param>
    /// <returns>True if the test completed (passed or failed) by this call, false otherwise.</returns>
    protected bool CheckCompletionAfterDuration(
      double milliseconds,
      Func<bool>? successCondition = null,
      Func<string>? passDetails = null,
      Func<string>? failDetailsTimeout = null,
      Func<string>? failDetailsCondition = null)
    {
      if (this.IsDone)
      {
        return true; // Already done, report as handled
      }

      if (this.TestStopwatch.ElapsedMilliseconds >= milliseconds)
      {
        if (successCondition == null || successCondition())
        {
          this.CurrentStatus = TestStatus.Passed;
          this.Details = passDetails != null ? passDetails() : "Test passed: Met condition or reached duration.";
        }
        else
        {
          this.CurrentStatus = TestStatus.Failed;

          // If condition failed, use failDetailsCondition, otherwise (timeout without specific condition failure) use failDetailsTimeout
          this.Details = failDetailsCondition != null ? failDetailsCondition() : (failDetailsTimeout != null ? failDetailsTimeout() : "Test failed: Condition not met or timed out.");
        }

        this.EndTest();
        return true; // Test completed
      }

      return false; // Test not yet completed
    }

    /// <summary>
    /// Checks if the test should complete based on a number of frames.
    /// Sets CurrentStatus, Details, and calls EndTest if completion occurs.
    /// </summary>
    /// <param name="frameCount">The number of frames to wait.</param>
    /// <param name="successCondition">An optional function that must return true for the test to pass. If null, test passes after frameCount.</param>
    /// <param name="passDetails">Details message if the test passes.</param>
    /// <param name="failDetailsFrameLimit">Details message if the test fails due to exceeding frame limit (and no successCondition or it was false).</param>
    /// <param name="failDetailsCondition">Details message if the test fails because successCondition was false at frame limit.</param>
    /// <returns>True if the test completed (passed or failed) by this call, false otherwise.</returns>
    protected bool CheckCompletionAfterFrames(
      int frameCount,
      Func<bool>? successCondition = null,
      Func<string>? passDetails = null,
      Func<string>? failDetailsFrameLimit = null,
      Func<string>? failDetailsCondition = null)
    {
      if (this.IsDone)
      {
        return true; // Already done, report as handled
      }

      if (this.CurrentFrameCount >= frameCount)
      {
        if (successCondition == null || successCondition())
        {
          this.CurrentStatus = TestStatus.Passed;
          this.Details = passDetails != null ? passDetails() : "Test passed: Met condition or reached frame limit.";
        }
        else
        {
          this.CurrentStatus = TestStatus.Failed;

          // If condition failed, use failDetailsCondition, otherwise (timeout without specific condition failure) use failDetailsFrameLimit
          this.Details = failDetailsCondition != null ? failDetailsCondition() : (failDetailsFrameLimit != null ? failDetailsFrameLimit() : "Test failed: Condition not met or frame limit exceeded.");
        }

        this.EndTest();
        return true; // Test completed
      }

      return false; // Test not yet completed
    }
  }
}
