name: Release Night Library (GitHub Release)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Semantic Version for the release (e.g., 1.0.0, 1.0.0-beta.1). This is the pure SemVer."
        required: true
        type: string

permissions:
  contents: write # To create commits, tags, and releases

jobs:
  release:
    name: Build and Create GitHub Release for Night Library
    runs-on: ubuntu-latest
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      SOLUTION_FILE_PATH: Night.sln
      MAIN_PROJECT_FILE_PATH: src/Night/Night.csproj
      VERSION_INFO_FILE_PATH: src/Night/VersionInfo.cs # Path to the version C# file
      TEST_PROJECT_FILE_PATH: tests/Night.Tests/Night.Tests.csproj
      PACKAGE_OUTPUT_DIR: ./packages

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to analyze history
          submodules: "recursive"

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Validate Version Input (SemVer)
        run: |
          echo "Starting SemVer validation..."
          version_input_raw="${{ github.event.inputs.version }}"
          echo "Raw version_input (length ${#version_input_raw}): >${version_input_raw}<"
          echo "Raw version_input (hex):"
          echo -n "${version_input_raw}" | od -tx1 -c

          # Trim whitespace using a more direct bash method
          # Remove leading whitespace
          temp_trimmed_input="${version_input_raw#"${version_input_raw%%[![:space:]]*}"}"
          # Remove trailing whitespace
          version_input="${temp_trimmed_input%"${temp_trimmed_input##*[![:space:]]}"}"

          echo "Trimmed version_input (length ${#version_input}): >${version_input}<"
          echo "Trimmed version_input (hex):"
          echo -n "${version_input}" | od -tx1 -c

          # Use single quotes for the regex pattern for robustness
          semver_regex='^([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$'
          echo "Using semver_regex: >${semver_regex}<"

          # Clear BASH_REMATCH for a clean test
          unset BASH_REMATCH

          if [[ "$version_input" =~ $semver_regex ]]; then
            echo "SemVer input '$version_input' is VALID."
            echo "BASH_REMATCH[0] (Full match): >${BASH_REMATCH[0]}<"
            echo "BASH_REMATCH[1] (Major): >${BASH_REMATCH[1]}<"
            echo "BASH_REMATCH[2] (Minor): >${BASH_REMATCH[2]}<"
            echo "BASH_REMATCH[3] (Patch): >${BASH_REMATCH[3]}<"
            echo "BASH_REMATCH[4] (Pre-release): >${BASH_REMATCH[4]}<"
            echo "BASH_REMATCH[5] (Build metadata): >${BASH_REMATCH[5]}<"
          else
            echo "SemVer input '$version_input' is INVALID."
            if [ ${#BASH_REMATCH[@]} -gt 0 ]; then
              echo "DEBUG: BASH_REMATCH was set despite failed match (unexpected):"
              for i in "${!BASH_REMATCH[@]}"; do
                echo "DEBUG: BASH_REMATCH[$i]: >${BASH_REMATCH[$i]}<"
              done
            else
              echo "DEBUG: BASH_REMATCH is empty as expected on failure."
            fi
            echo "Error: Invalid version format. Input must be a pure Semantic Version (e.g., 1.0.0, 1.2.3-beta.1)."
            echo "Input was (length ${#version_input}): >$version_input<"
            exit 1
          fi
        shell: bash

      - name: Update Version in .csproj
        id: update_version_csproj
        run: |
          $newSemVer = "${{ github.event.inputs.version }}"
          $projectFilePath = "${{ env.MAIN_PROJECT_FILE_PATH }}"
          Write-Host "Attempting to update <Version> in '$projectFilePath' to '$newSemVer'"
          [xml]$csproj = Get-Content -Path $projectFilePath -Raw
          $versionNode = $csproj.SelectSingleNode("//PropertyGroup/Version")
          if (-not $versionNode) {
              $propertyGroupNode = $csproj.SelectSingleNode("//PropertyGroup")
              if (-not $propertyGroupNode) {
                  $propertyGroupNode = $csproj.CreateElement("PropertyGroup")
                  $csproj.Project.AppendChild($propertyGroupNode) | Out-Null
              }
              $versionNode = $csproj.CreateElement("Version")
              $propertyGroupNode.AppendChild($versionNode) | Out-Null
          }
          $versionNode.InnerText = $newSemVer
          $csproj.Save($projectFilePath)
          Write-Host "Saved <Version> $newSemVer to '$projectFilePath'"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version_tag=v$newSemVer"
        shell: pwsh

      - name: Update Version in VersionInfo.cs
        run: |
          $newSemVer = "${{ github.event.inputs.version }}"
          $versionInfoFilePath = "${{ env.VERSION_INFO_FILE_PATH }}"
          Write-Host "Attempting to update Version constant in '$versionInfoFilePath' to '$newSemVer'"
          $content = Get-Content -Path $versionInfoFilePath -Raw
          # Regex to find 'public const string Version = ".*";' and replace the version string part
          $updatedContent = $content -replace '(?<=public const string Version = ")([^"]*)(?=";)', $newSemVer

          # Ensure the content ends with a single LF newline.
          # Remove all trailing CR and LF characters, then add a single LF.
          $updatedContent = $updatedContent.TrimEnd("`r", "`n") + "`n"

          # Write the content. UTF-8 is standard for .cs files.
          Set-Content -Path $versionInfoFilePath -Value $updatedContent -Encoding UTF8

          Write-Host "Updated Version constant in '$versionInfoFilePath', ensuring it ends with a single LF newline."
        shell: pwsh

      - name: Commit Version Changes
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          git add "${{ env.MAIN_PROJECT_FILE_PATH }}" # .csproj
          git add "${{ env.VERSION_INFO_FILE_PATH }}" # VersionInfo.cs
          git commit -m "Version ${{ github.event.inputs.version }}"
          echo "Committed version updates for ${{ github.event.inputs.version }}"
        shell: bash

      - name: Create Git Tag
        run: |
          git tag "${{ steps.update_version_csproj.outputs.version_tag }}"
          echo "Created git tag ${{ steps.update_version_csproj.outputs.version_tag }}"
        shell: bash

      - name: Push Commit and Tag
        run: |
          git push origin HEAD:main
          echo "Pushed commit to main."
          git push origin "${{ steps.update_version_csproj.outputs.version_tag }}"
          echo "Pushed tag ${{ steps.update_version_csproj.outputs.version_tag }} to remote."
        shell: bash

      - name: Prepare SDL3 Prebuilt Binaries
        run: |
          echo "Looking for SDL3 prebuilt binary ZIP files in platform-specific subdirectories under lib/SDL3-Prebuilt..."
          SDL_PREBUILT_DIR="lib/SDL3-Prebuilt"

          if ! command -v unzip &> /dev/null; then
            echo "Error: unzip command not found. Please ensure it's installed on the runner."
            exit 1
          fi

          # Linux
          TARGET_ZIP_BASENAME_LINUX="linux"
          TARGET_PLATFORM_DIR_LINUX="linux"
          PLATFORM_DIR_PATH_LINUX="$SDL_PREBUILT_DIR/$TARGET_PLATFORM_DIR_LINUX"
          PLATFORM_ARCHIVE_PATH_LINUX="$PLATFORM_DIR_PATH_LINUX/$TARGET_ZIP_BASENAME_LINUX.zip"
          PLATFORM_ARCHIVE_ALT_PATH_LINUX="$PLATFORM_DIR_PATH_LINUX/$TARGET_ZIP_BASENAME_LINUX-binaries.zip"
          EXTRACTION_DIR_LINUX="$PLATFORM_DIR_PATH_LINUX"

          echo "Attempting to extract for $TARGET_PLATFORM_DIR_LINUX from $PLATFORM_DIR_PATH_LINUX into $EXTRACTION_DIR_LINUX..."
          mkdir -p "$EXTRACTION_DIR_LINUX" # Ensure platform directory exists
          if [ -f "$PLATFORM_ARCHIVE_PATH_LINUX" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_LINUX binaries from $PLATFORM_ARCHIVE_PATH_LINUX..."
            unzip -qo "$PLATFORM_ARCHIVE_PATH_LINUX" -d "$EXTRACTION_DIR_LINUX/"
            echo "Extracted $TARGET_PLATFORM_DIR_LINUX binaries from $PLATFORM_ARCHIVE_PATH_LINUX."
          elif [ -f "$PLATFORM_ARCHIVE_ALT_PATH_LINUX" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_LINUX binaries from $PLATFORM_ARCHIVE_ALT_PATH_LINUX..."
            unzip -qo "$PLATFORM_ARCHIVE_ALT_PATH_LINUX" -d "$EXTRACTION_DIR_LINUX/"
            echo "Extracted $TARGET_PLATFORM_DIR_LINUX binaries from $PLATFORM_ARCHIVE_ALT_PATH_LINUX."
          else
            echo "Info: No $TARGET_PLATFORM_DIR_LINUX SDL binaries ZIP found (checked for $PLATFORM_ARCHIVE_PATH_LINUX and $PLATFORM_ARCHIVE_ALT_PATH_LINUX)."
          fi

          # macOS
          TARGET_ZIP_BASENAME_MACOS="macos"
          TARGET_PLATFORM_DIR_MACOS="macos"
          PLATFORM_DIR_PATH_MACOS="$SDL_PREBUILT_DIR/$TARGET_PLATFORM_DIR_MACOS"
          PLATFORM_ARCHIVE_PATH_MACOS="$PLATFORM_DIR_PATH_MACOS/$TARGET_ZIP_BASENAME_MACOS.zip"
          PLATFORM_ARCHIVE_ALT_PATH_MACOS="$PLATFORM_DIR_PATH_MACOS/$TARGET_ZIP_BASENAME_MACOS-binaries.zip"
          EXTRACTION_DIR_MACOS="$PLATFORM_DIR_PATH_MACOS"

          echo "Attempting to extract for $TARGET_PLATFORM_DIR_MACOS from $PLATFORM_DIR_PATH_MACOS into $EXTRACTION_DIR_MACOS..."
          mkdir -p "$EXTRACTION_DIR_MACOS" # Ensure platform directory exists
          if [ -f "$PLATFORM_ARCHIVE_PATH_MACOS" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_MACOS binaries from $PLATFORM_ARCHIVE_PATH_MACOS..."
            unzip -qo "$PLATFORM_ARCHIVE_PATH_MACOS" -d "$EXTRACTION_DIR_MACOS/"
            echo "Extracted $TARGET_PLATFORM_DIR_MACOS binaries from $PLATFORM_ARCHIVE_PATH_MACOS."
          elif [ -f "$PLATFORM_ARCHIVE_ALT_PATH_MACOS" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_MACOS binaries from $PLATFORM_ARCHIVE_ALT_PATH_MACOS..."
            unzip -qo "$PLATFORM_ARCHIVE_ALT_PATH_MACOS" -d "$EXTRACTION_DIR_MACOS/"
            echo "Extracted $TARGET_PLATFORM_DIR_MACOS binaries from $PLATFORM_ARCHIVE_ALT_PATH_MACOS."
          else
            echo "Info: No $TARGET_PLATFORM_DIR_MACOS SDL binaries ZIP found (checked for $PLATFORM_ARCHIVE_PATH_MACOS and $PLATFORM_ARCHIVE_ALT_PATH_MACOS)."
          fi

          # Windows
          TARGET_ZIP_BASENAME_WINDOWS="windows"
          TARGET_PLATFORM_DIR_WINDOWS="windows"
          PLATFORM_DIR_PATH_WINDOWS="$SDL_PREBUILT_DIR/$TARGET_PLATFORM_DIR_WINDOWS"
          PLATFORM_ARCHIVE_PATH_WINDOWS="$PLATFORM_DIR_PATH_WINDOWS/$TARGET_ZIP_BASENAME_WINDOWS.zip"
          PLATFORM_ARCHIVE_ALT_PATH_WINDOWS="$PLATFORM_DIR_PATH_WINDOWS/$TARGET_ZIP_BASENAME_WINDOWS-binaries.zip"
          EXTRACTION_DIR_WINDOWS="$PLATFORM_DIR_PATH_WINDOWS"

          echo "Attempting to extract for $TARGET_PLATFORM_DIR_WINDOWS from $PLATFORM_DIR_PATH_WINDOWS into $EXTRACTION_DIR_WINDOWS..."
          mkdir -p "$EXTRACTION_DIR_WINDOWS" # Ensure platform directory exists
          if [ -f "$PLATFORM_ARCHIVE_PATH_WINDOWS" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_WINDOWS binaries from $PLATFORM_ARCHIVE_PATH_WINDOWS..."
            unzip -qo "$PLATFORM_ARCHIVE_PATH_WINDOWS" -d "$EXTRACTION_DIR_WINDOWS/"
            echo "Extracted $TARGET_PLATFORM_DIR_WINDOWS binaries from $PLATFORM_ARCHIVE_PATH_WINDOWS."
          elif [ -f "$PLATFORM_ARCHIVE_ALT_PATH_WINDOWS" ]; then
            echo "Extracting $TARGET_PLATFORM_DIR_WINDOWS binaries from $PLATFORM_ARCHIVE_ALT_PATH_WINDOWS..."
            unzip -qo "$PLATFORM_ARCHIVE_ALT_PATH_WINDOWS" -d "$EXTRACTION_DIR_WINDOWS/"
            echo "Extracted $TARGET_PLATFORM_DIR_WINDOWS binaries from $PLATFORM_ARCHIVE_ALT_PATH_WINDOWS."
          else
            echo "Info: No $TARGET_PLATFORM_DIR_WINDOWS SDL binaries ZIP found (checked for $PLATFORM_ARCHIVE_PATH_WINDOWS and $PLATFORM_ARCHIVE_ALT_PATH_WINDOWS)."
          fi

          echo "Final listing of contents in $SDL_PREBUILT_DIR after extraction attempts:"
          ls -R "$SDL_PREBUILT_DIR"
        shell: bash

      - name: Build Solution
        run: dotnet build "${{ env.SOLUTION_FILE_PATH }}" -c Release /p:Version="${{ github.event.inputs.version }}"

      - name: Run Tests
        run: dotnet test "${{ env.SOLUTION_FILE_PATH }}" --no-build -c Release

      - name: Create Package Output Directory
        run: mkdir -p "${{ env.PACKAGE_OUTPUT_DIR }}"

      - name: Package Library
        run: |
          dotnet pack "${{ env.MAIN_PROJECT_FILE_PATH }}" `
            --no-build `
            -c Release `
            -o "${{ env.PACKAGE_OUTPUT_DIR }}" `
            /p:Version="${{ github.event.inputs.version }}" `
            /p:IncludeSymbols=true `
            /p:SymbolPackageFormat=snupkg
        shell: pwsh

      - name: List Packaged Files
        run: ls -R "${{ env.PACKAGE_OUTPUT_DIR }}"
        shell: bash

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION_TAG: ${{ steps.update_version_csproj.outputs.version_tag }}
          RELEASE_VERSION: ${{ github.event.inputs.version }}
        run: |
          gh release create "$VERSION_TAG" \
            "${{ env.PACKAGE_OUTPUT_DIR }}"/*.nupkg \
            "${{ env.PACKAGE_OUTPUT_DIR }}"/*.snupkg \
            --title "v$RELEASE_VERSION" \
            --notes "Night Engine Release $RELEASE_VERSION" \
            --draft=false
        shell: bash
